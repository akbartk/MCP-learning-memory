/**
 * Note Processor Library - Note Validation and Processing Pipeline
 * 
 * Menyediakan functionality untuk validasi, processing, dan enrichment notes
 * Mendukung text analysis, summarization, dan embedding generation
 * 
 * @author MCP Server Team
 * @version 1.0.0
 */

import { v4 as uuidv4 } from 'uuid';
import validator from './validator.js';
import embeddings from './embeddings.js';

/**
 * Note Processor Class
 */
export class NoteProcessor {
  constructor(config = {}) {
    this.config = {
      maxTitleLength: config.maxTitleLength || 200,
      maxContentLength: config.maxContentLength || 50000,
      maxTagCount: config.maxTagCount || 20,
      maxTagLength: config.maxTagLength || 50,
      autoSummarize: config.autoSummarize !== false,
      autoTags: config.autoTags !== false,
      autoEmbeddings: config.autoEmbeddings !== false,
      summaryMaxLength: config.summaryMaxLength || 500,
      enableProfanityFilter: config.enableProfanityFilter || false,
      ...config
    };

    this.validator = validator;
    this.embeddings = embeddings;
    this.processingStats = {
      processed: 0,
      errors: 0,
      startTime: Date.now()
    };
  }

  /**
   * Process note lengkap dengan validation, enrichment, dan embedding
   * @param {Object} noteData - Raw note data
   * @param {Object} options - Processing options
   * @returns {Object} Processed note
   */
  async processNote(noteData, options = {}) {
    const startTime = Date.now();
    try {
      
      // Step 1: Validate input
      const validationResult = await this.validator.validateNote(noteData);
      if (!validationResult.valid) {
        throw new Error(`Validation failed: ${validationResult.errors.join(', ')}`);
      }

      // Step 2: Sanitize dan normalize data
      const sanitizedNote = await this.sanitizeNote(validationResult.sanitized);

      // Step 3: Generate ID jika belum ada
      if (!sanitizedNote.id) {
        sanitizedNote.id = uuidv4();
      }

      // Step 4: Extract metadata
      const metadata = await this.extractMetadata(sanitizedNote);

      // Step 5: Generate summary jika enabled
      let summary = sanitizedNote.summary;
      if (this.config.autoSummarize && !summary && sanitizedNote.content) {
        summary = await this.generateSummary(sanitizedNote.content);
      }

      // Step 6: Generate tags jika enabled
      let tags = sanitizedNote.tags || [];
      if (this.config.autoTags && sanitizedNote.content) {
        const autoTags = await this.generateTags(sanitizedNote.content, sanitizedNote.title);
        tags = [...new Set([...tags, ...autoTags])]; // Merge dan deduplicate
      }

      // Step 7: Generate embeddings jika enabled
      let embedding = sanitizedNote.embedding;
      if (this.config.autoEmbeddings && sanitizedNote.content) {
        const textForEmbedding = this.prepareTextForEmbedding(sanitizedNote);
        embedding = await this.embeddings.generateEmbedding(textForEmbedding);
      }

      // Step 8: Determine category jika belum ada
      const category = sanitizedNote.category || await this.classifyCategory(sanitizedNote, tags);

      // Step 9: Calculate priority jika belum ada
      const priority = sanitizedNote.priority !== undefined 
        ? sanitizedNote.priority 
        : await this.calculatePriority(sanitizedNote, tags);

      // Step 10: Build final processed note
      const processedNote = {
        id: sanitizedNote.id,
        userId: sanitizedNote.userId,
        title: sanitizedNote.title,
        content: sanitizedNote.content,
        summary,
        tags: tags.slice(0, this.config.maxTagCount), // Limit tag count
        category,
        priority,
        embedding,
        metadata: {
          ...sanitizedNote.metadata,
          ...metadata,
          processing: {
            version: '1.0.0',
            processedAt: new Date().toISOString(),
            processingTime: Date.now() - startTime,
            autoGenerated: {
              summary: this.config.autoSummarize && !sanitizedNote.summary,
              tags: this.config.autoTags,
              embedding: this.config.autoEmbeddings,
              category: !sanitizedNote.category,
              priority: sanitizedNote.priority === undefined
            }
          }
        },
        createdAt: sanitizedNote.createdAt || new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      // Update statistics
      this.processingStats.processed++;

      return {
        success: true,
        note: processedNote,
        metadata: {
          processingTime: Date.now() - startTime,
          validationPassed: true,
          enrichmentApplied: {
            summary: !!summary && this.config.autoSummarize,
            tags: this.config.autoTags,
            embedding: this.config.autoEmbeddings,
            category: !sanitizedNote.category,
            priority: sanitizedNote.priority === undefined
          }
        }
      };

    } catch (error) {
      this.processingStats.errors++;
      
      return {
        success: false,
        error: error.message,
        originalNote: noteData,
        metadata: {
          processingTime: Date.now() - (startTime || Date.now()),
          validationPassed: false
        }
      };
    }
  }

  /**
   * Batch processing untuk multiple notes
   * @param {Array} notes - Array of note data
   * @param {Object} options - Processing options
   * @returns {Object} Batch processing results
   */
  async batchProcess(notes, options = {}) {
    const {
      concurrency = 5,
      continueOnError = true,
      progressCallback = null
    } = options;

    const results = {
      successful: [],
      failed: [],
      totalProcessed: 0,
      totalErrors: 0,
      startTime: Date.now()
    };

    // Process in chunks untuk avoid memory issues
    const chunks = this.chunkArray(notes, concurrency);
    
    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
      const chunk = chunks[chunkIndex];
      
      const chunkPromises = chunk.map(async (note, index) => {
        try {
          const result = await this.processNote(note, options);
          
          if (result.success) {
            results.successful.push(result);
          } else {
            results.failed.push(result);
            results.totalErrors++;
          }
          
          results.totalProcessed++;
          
          // Progress callback
          if (progressCallback) {
            progressCallback({
              processed: results.totalProcessed,
              total: notes.length,
              chunkIndex,
              totalChunks: chunks.length,
              currentNote: note
            });
          }
          
          return result;
        } catch (error) {
          const failedResult = {
            success: false,
            error: error.message,
            originalNote: note
          };
          
          results.failed.push(failedResult);
          results.totalErrors++;
          results.totalProcessed++;
          
          if (!continueOnError) {
            throw error;
          }
          
          return failedResult;
        }
      });

      await Promise.all(chunkPromises);
    }

    results.endTime = Date.now();
    results.totalTime = results.endTime - results.startTime;
    results.averageProcessingTime = results.totalTime / results.totalProcessed;

    return results;
  }

  /**
   * Sanitize note data
   */
  async sanitizeNote(note) {
    const sanitized = { ...note };

    // Trim dan normalize text fields
    if (sanitized.title) {
      sanitized.title = sanitized.title.trim().substring(0, this.config.maxTitleLength);
    }

    if (sanitized.content) {
      sanitized.content = sanitized.content.trim().substring(0, this.config.maxContentLength);
    }

    if (sanitized.summary) {
      sanitized.summary = sanitized.summary.trim().substring(0, this.config.summaryMaxLength);
    }

    // Sanitize tags
    if (sanitized.tags && Array.isArray(sanitized.tags)) {
      sanitized.tags = sanitized.tags
        .map(tag => String(tag).trim().toLowerCase())
        .filter(tag => tag.length > 0 && tag.length <= this.config.maxTagLength)
        .slice(0, this.config.maxTagCount);
    }

    // Profanity filter jika enabled
    if (this.config.enableProfanityFilter) {
      sanitized.title = this.filterProfanity(sanitized.title);
      sanitized.content = this.filterProfanity(sanitized.content);
      sanitized.summary = this.filterProfanity(sanitized.summary);
    }

    return sanitized;
  }

  /**
   * Extract metadata dari note content
   */
  async extractMetadata(note) {
    const metadata = {
      wordCount: 0,
      characterCount: 0,
      estimatedReadingTime: 0,
      language: 'en',
      complexity: 'medium',
      topics: []
    };

    if (note.content) {
      metadata.characterCount = note.content.length;
      metadata.wordCount = note.content.split(/\s+/).filter(word => word.length > 0).length;
      metadata.estimatedReadingTime = Math.ceil(metadata.wordCount / 200); // 200 words per minute
      
      // Simple language detection
      metadata.language = this.detectLanguage(note.content);
      
      // Complexity analysis
      metadata.complexity = this.analyzeComplexity(note.content);
      
      // Extract topics/themes
      metadata.topics = await this.extractTopics(note.content);
    }

    return metadata;
  }

  /**
   * Generate summary dari content
   */
  async generateSummary(content) {
    try {
      // Simple extractive summarization
      const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 10);
      
      if (sentences.length <= 2) {
        return content.substring(0, this.config.summaryMaxLength);
      }

      // Score sentences berdasarkan position dan word frequency
      const sentenceScores = this.scoreSentences(sentences, content);
      
      // Ambil top sentences
      const topSentences = sentenceScores
        .sort((a, b) => b.score - a.score)
        .slice(0, Math.min(3, Math.ceil(sentences.length / 3)))
        .sort((a, b) => a.index - b.index)
        .map(item => item.sentence);

      const summary = topSentences.join('. ').trim();
      return summary.length > this.config.summaryMaxLength 
        ? summary.substring(0, this.config.summaryMaxLength) + '...'
        : summary;
    } catch (error) {
      console.warn('⚠️ Failed to generate summary:', error);
      return content.substring(0, this.config.summaryMaxLength);
    }
  }

  /**
   * Generate tags otomatis dari content
   */
  async generateTags(content, title = '') {
    try {
      const text = (title + ' ' + content).toLowerCase();
      
      // Extract keywords menggunakan TF-IDF sederhana
      const words = text.match(/\b\w{3,}\b/g) || [];
      const wordFreq = {};
      
      // Count frequencies
      words.forEach(word => {
        wordFreq[word] = (wordFreq[word] || 0) + 1;
      });

      // Simple stopwords (bisa diperluas)
      const stopwords = new Set(['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'who', 'boy', 'did', 'man', 'men', 'she', 'too', 'way', 'what', 'when', 'with', 'this', 'that', 'they', 'have', 'from', 'been', 'said', 'each', 'which', 'their', 'would', 'there', 'could']);

      // Filter dan score words
      const candidates = Object.entries(wordFreq)
        .filter(([word, freq]) => 
          !stopwords.has(word) && 
          word.length >= 3 && 
          word.length <= this.config.maxTagLength &&
          freq >= 2
        )
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([word]) => word);

      return candidates;
    } catch (error) {
      console.warn('⚠️ Failed to generate tags:', error);
      return [];
    }
  }

  /**
   * Classify category berdasarkan content dan tags
   */
  async classifyCategory(note, tags = []) {
    const categoryKeywords = {
      'work': ['meeting', 'project', 'deadline', 'task', 'business', 'office', 'client', 'report'],
      'personal': ['family', 'friend', 'vacation', 'hobby', 'home', 'personal', 'life'],
      'learning': ['learn', 'study', 'research', 'education', 'course', 'tutorial', 'knowledge'],
      'ideas': ['idea', 'concept', 'innovation', 'creative', 'brainstorm', 'invention'],
      'health': ['health', 'fitness', 'exercise', 'medical', 'doctor', 'wellness'],
      'finance': ['money', 'budget', 'investment', 'finance', 'bank', 'cost', 'expense'],
      'technology': ['tech', 'software', 'programming', 'code', 'computer', 'digital'],
      'travel': ['travel', 'trip', 'journey', 'destination', 'flight', 'hotel']
    };

    const text = (note.title + ' ' + note.content + ' ' + tags.join(' ')).toLowerCase();
    
    let bestCategory = 'general';
    let bestScore = 0;

    for (const [category, keywords] of Object.entries(categoryKeywords)) {
      const score = keywords.reduce((sum, keyword) => {
        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
        const matches = text.match(regex);
        return sum + (matches ? matches.length : 0);
      }, 0);

      if (score > bestScore) {
        bestScore = score;
        bestCategory = category;
      }
    }

    return bestCategory;
  }

  /**
   * Calculate priority berdasarkan various factors
   */
  async calculatePriority(note, tags = []) {
    let priority = 0;

    // Priority keywords
    const urgentKeywords = ['urgent', 'asap', 'deadline', 'important', 'critical', 'emergency'];
    const highKeywords = ['meeting', 'presentation', 'interview', 'exam', 'appointment'];
    
    const text = (note.title + ' ' + note.content + ' ' + tags.join(' ')).toLowerCase();

    // Check urgent keywords
    urgentKeywords.forEach(keyword => {
      if (text.includes(keyword)) priority += 3;
    });

    // Check high priority keywords
    highKeywords.forEach(keyword => {
      if (text.includes(keyword)) priority += 2;
    });

    // Factor in note length (longer notes might be more important)
    if (note.content && note.content.length > 1000) priority += 1;

    // Factor in tag count (more tags might indicate importance)
    if (tags.length > 5) priority += 1;

    // Cap priority
    return Math.min(priority, 5);
  }

  /**
   * Prepare text untuk embedding generation
   */
  prepareTextForEmbedding(note) {
    const parts = [];
    
    if (note.title) parts.push(note.title);
    if (note.summary) parts.push(note.summary);
    if (note.content) parts.push(note.content.substring(0, 2000)); // Limit untuk embedding
    
    return parts.join(' ').trim();
  }

  /**
   * Helper methods
   */
  chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }

  scoreSentences(sentences, fullContent) {
    const words = fullContent.toLowerCase().match(/\b\w+\b/g) || [];
    const wordFreq = {};
    words.forEach(word => wordFreq[word] = (wordFreq[word] || 0) + 1);

    return sentences.map((sentence, index) => {
      const sentenceWords = sentence.toLowerCase().match(/\b\w+\b/g) || [];
      const score = sentenceWords.reduce((sum, word) => sum + (wordFreq[word] || 0), 0) / sentenceWords.length;
      
      // Boost first sentences
      const positionBoost = index < 3 ? 1.5 : 1;
      
      return {
        sentence: sentence.trim(),
        score: score * positionBoost,
        index
      };
    });
  }

  detectLanguage(text) {
    // Simple language detection (bisa diganti dengan library yang lebih sophisticated)
    const englishWords = ['the', 'and', 'to', 'of', 'a', 'in', 'for', 'is', 'on', 'that'];
    const indonesianWords = ['dan', 'yang', 'di', 'untuk', 'dengan', 'dari', 'pada', 'ini', 'itu', 'atau'];
    
    const words = text.toLowerCase().split(/\s+/);
    const englishCount = words.filter(word => englishWords.includes(word)).length;
    const indonesianCount = words.filter(word => indonesianWords.includes(word)).length;
    
    return indonesianCount > englishCount ? 'id' : 'en';
  }

  analyzeComplexity(text) {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const words = text.split(/\s+/).filter(w => w.length > 0);
    
    const avgWordsPerSentence = words.length / sentences.length;
    const avgCharsPerWord = text.replace(/\s+/g, '').length / words.length;
    
    if (avgWordsPerSentence > 20 || avgCharsPerWord > 6) return 'high';
    if (avgWordsPerSentence > 15 || avgCharsPerWord > 5) return 'medium';
    return 'low';
  }

  async extractTopics(content) {
    // Simple topic extraction berdasarkan common patterns
    const topics = [];
    const topicPatterns = {
      'programming': /\b(code|coding|programming|software|development|algorithm)\b/gi,
      'business': /\b(business|meeting|project|management|strategy|profit)\b/gi,
      'health': /\b(health|fitness|exercise|diet|medical|wellness)\b/gi,
      'education': /\b(learn|study|education|course|training|research)\b/gi,
      'technology': /\b(technology|tech|digital|ai|machine learning|data)\b/gi
    };

    for (const [topic, pattern] of Object.entries(topicPatterns)) {
      if (pattern.test(content)) {
        topics.push(topic);
      }
    }

    return topics;
  }

  filterProfanity(text) {
    if (!text) return text;
    
    // Simple profanity filter (dalam implementasi nyata, gunakan library yang lebih comprehensive)
    const badWords = ['damn', 'hell', 'stupid']; // Tambah sesuai kebutuhan
    let filtered = text;
    
    badWords.forEach(word => {
      const regex = new RegExp(`\\b${word}\\b`, 'gi');
      filtered = filtered.replace(regex, '*'.repeat(word.length));
    });
    
    return filtered;
  }

  /**
   * Get processing statistics
   */
  getStatistics() {
    const uptime = Date.now() - this.processingStats.startTime;
    
    return {
      ...this.processingStats,
      uptime,
      processingRate: this.processingStats.processed / (uptime / 1000 / 60), // per minute
      errorRate: this.processingStats.errors / Math.max(this.processingStats.processed, 1),
      config: this.config
    };
  }

  /**
   * Reset statistics
   */
  resetStatistics() {
    this.processingStats = {
      processed: 0,
      errors: 0,
      startTime: Date.now()
    };
  }
}

/**
 * Default instance
 */
const noteProcessor = new NoteProcessor();

export default noteProcessor;

/**
 * Named exports
 */
export { validator, embeddings };